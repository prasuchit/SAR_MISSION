;;; Copyright (c) 2016, Fereshta Yazdani <yazdani@cs.uni-bremen.de>
;;; All rights reserved.
;; 
;;; Redistribution and use in source and binary forms, with or without
;;; modification, are permitted provided that the following conditions are met:
;;; 
;;;     * Redistributions of source code must retain the above copyright
;;;       notice, this list of conditions and the following disclaimer.
;;;     * Redistributions in binary form must reproduce the above copyright
;;;       notice, this list of conditions and the following disclaimer in the
;;;       documentation and/or other materials provided with the distribution.
;;;     * Neither the name of the Institute for Artificial Intelligence/
;;;       Universitaet Bremen nor the names of its contributors may be used to 
;;;       endorse or promote products derived from this software without 
;;;       specific prior written permission.
;;; 
;;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
;;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;;; POSSIBILITY OF SUCH DAMAGE.

(in-package :start-mission)

(defun get-elem-pose (name &optional (sem-map (sem-map-utils::get-semantic-map)))
 (let*((pose NIL)
       (sem-hash (slot-value sem-map 'sem-map-utils:parts))
       (sem-keys (hash-table-keys sem-hash)))
       (dotimes (i (length sem-keys))
         do(if (string-equal name (nth i sem-keys))
               (setf pose (slot-value (gethash name sem-hash) 'sem-map-utils:pose))
               (format t "")))
   pose))

(defun elem-in-list (name sem-map)
  (let*((sem-hash (slot-value sem-map 'sem-map-utils:parts))
        (sem-keys (hash-table-keys sem-hash))
        (ret NIL))
    (dotimes (index (length sem-keys))
      do(cond ((string-equal name (get-elem-type (nth index sem-keys) sem-map))
               (setf ret NIL)
               (return))
	      (t (setf ret (format NIL "Error: The NL-object '~a' is not inside the map!" name)))))
    ret))

(defun get-elem-type (name sem-map)
 (let*((type NIL)
       (sem-hash (slot-value sem-map 'sem-map-utils:parts))
       (sem-keys (hash-table-keys sem-hash)))
       (loop for i from 0 to (- (length sem-keys) 1)
             do(cond ((string-equal name (nth i sem-keys))
                      (setf type (slot-value (gethash name sem-hash)
                                             'cram-semantic-map-utils::type)))
                     (t ())))
   type))

;;
;; Getting the biggest object inside the map
;;
(defun calculate-big-object (nom sem-map)
  (let*((sem-hash (slot-value sem-map 'sem-map-utils:parts))
        (sem-keys (hash-table-keys sem-hash))
        (name NIL)
        (list-keys '())
        (value 0))
    (cond ((not (equal (elem-in-list nom sem-map) NIL))
           (setf name (elem-in-list nom sem-map)))
          (t
           (dotimes (mass (length sem-keys))
             do(if(string-equal (get-elem-type (nth mass sem-keys) sem-map) nom)
                  (setf list-keys (cons (nth mass sem-keys) list-keys))
                  (format t "")))
           (dotimes (index (length list-keys))
             do(cond((< value (bbox-sum (nth index list-keys) sem-hash))
                     (setf name (nth index list-keys))
                     (setf value (bbox-sum (nth index list-keys) sem-hash)))
             (t ())))))
    name))

;;
;; Getting the smallest object inside the map
;;
(defun calculate-small-object (nom sem-map)
  (let*((sem-hash (slot-value sem-map 'sem-map-utils:parts))
        (sem-keys (hash-table-keys sem-hash))
        (name NIL)
        (list-keys '())
        (value 1000000))
    (cond ((not (equal (elem-in-list nom sem-map) NIL))
           (setf name (elem-in-list nom sem-map)))
          (t (dotimes (mass (length sem-keys))
               do(if(string-equal (get-elem-type (nth mass sem-keys) sem-map) nom)
                    (setf list-keys (cons (nth mass sem-keys) list-keys))
                    (format t "")))
             (dotimes (index (length list-keys))
               do(cond((> value (bbox-sum (nth index list-keys) sem-hash))
                       (setf name (nth index list-keys))
                       (setf value (bbox-sum (nth index list-keys) sem-hash)))
                      (t ())))))
    name))

;;
;; Calculating the sum of the bounding box
;;
(defun bbox-sum (name sem-hash)
  (let*((liste (get-bbox-as-aabb name sem-hash))
        (erst (first liste))
        (zweit (second liste))
        (sum NIL))
    (setf sum (+ (+ (cl-transforms:x erst) (cl-transforms:x zweit))
                 (+ (cl-transforms:y erst) (cl-transforms:y zweit))
                 (+ (cl-transforms:z erst) (cl-transforms:z zweit))))
    sum))

;;
;; Calculating all objects 
;; which are close to the human
;;
(defun objects-next-human (distance sem-map)
  ;(setf puber (swm->intern-tf-creater))
  (let* ((new-liste (visualize-plane distance))
         (sem-hash (slot-value sem-map 'sem-map-utils:parts))
         (sem-keys (hash-table-keys sem-hash))
         (elem NIL)
         (incrementer 1)
         (value NIL))
    ;(swm->intern-tf-remover puber)
    (dotimes (index (length new-liste))
      do(let*((new-point (nth index new-liste))
	      (smarter (+ (* 10 incrementer) index)))
	  (loop for jndex from 0 to (- (length sem-keys) 1)
		do(let* ((elem1 (first (get-bbox-as-aabb (nth jndex sem-keys) sem-hash)))
			 (elem2 (second (get-bbox-as-aabb (nth jndex sem-keys) sem-hash)))
			 (smarter (+ smarter jndex)))
		    (setf value
			  (semantic-map-costmap::inside-aabb elem1 elem2 (cl-transforms:origin new-point)))
		    (cond ((equal value T)
			   (setf elem (append (list (nth jndex sem-keys)) elem))
			   (location-costmap::publish-point (cl-transforms:origin new-point) :id smarter)
			   (remove-duplicates elem)
			   (return))
			  (t ;;   (location-costmap::publish-point (cl-transforms:origin new-point) :id smarter)
			   )))
		  (setf incrementer (+ incrementer 2)))))
    (reverse (remove-duplicates elem))))

;;
;;Getting the min and max values of a bounding box
;;
(defun get-bbox-as-aabb (name sem-hash)
(let*((dim-x (cl-transforms:x (slot-value (gethash name sem-hash) 'sem-map-utils:dimensions)))
      (dim-y (cl-transforms:y (slot-value (gethash name sem-hash) 'sem-map-utils:dimensions)))
      (dim-z (cl-transforms:z (slot-value (gethash name sem-hash) 'sem-map-utils:dimensions)))
      (pose-x (cl-transforms:x (cl-transforms:origin  (slot-value (gethash name sem-hash) 'sem-map-utils:pose))))
       (pose-y (cl-transforms:y (cl-transforms:origin  (slot-value (gethash name sem-hash) 'sem-map-utils:pose))))
      (min-vec (cl-transforms:make-3d-vector (- pose-x (/ dim-x 2))
                                             (- pose-y (/ dim-y 2))
                                             0))
      (max-vec (cl-transforms:make-3d-vector (+ pose-x (/ dim-x 2))
                                             (+ pose-y (/ dim-y 2))
                                             dim-z)))
  (cram-semantic-map-costmap::get-aabb min-vec max-vec)))


;;
;; Getting all the objects close to the rescuer...
;;
(defun get-objects-closer-human (geom-objects param object-pose)
  (let*((geom-list geom-objects)
      (objects NIL))
     (loop while (/= (length geom-list) 0) 
	do(cond ((and T
		      (compare-distance-of-objects (slot-value (car geom-list) 'sem-map-utils:pose) object-pose param))
		 (setf objects
		       (append objects (list (first geom-list))))
		 (setf geom-list (cdr geom-list)))
		(t (setf geom-list (cdr geom-list)))))
    objects))

(defun compare-distance-of-objects (obj_position pose param)
  (let*((vector (cl-transforms:origin pose))
        (x-vec (cl-transforms:x vector))
        (y-vec (cl-transforms:y vector))
        (z-vec (cl-transforms:z vector))
        (ge-vector (cl-transforms:origin obj_position))
        (x-ge (cl-transforms:x ge-vector))
        (y-ge (cl-transforms:y ge-vector))
        (z-ge (cl-transforms:z ge-vector))
        (test NIL))
    (if (> param (sqrt (+ (square (- x-vec x-ge))
                          (square (- y-vec y-ge))
                          (square (- z-vec z-ge)))))
     (setf test T)
     (setf test NIL))
    test))


(defun visualize-plane (num)
  (let* ((temp '()))
    (loop for jindex from 5 to num
          do(loop for smart from 0 to 30
                  do(loop for mass from 1 to 41 
                   do  (let*((new-point (get-gesture->relative-genius
                                          (cl-transforms:make-3d-vector
                                            jindex  (- mass 11) (- smart 15)))))
                                 (setf temp (cons new-point temp))))))
                 (reverse temp))) 



;;################################ POINTING GESTURE CALCULATIONS########################################;;

(defun give-pointed-at-no-bbox (point sem-map)
  (let*((elem NIL)
       (num (make-list 100))
      ; (eps 0)(var 0)
       (sem-hash (slot-value sem-map 'sem-map-utils:parts))
       (sem-keys (hash-table-keys sem-hash))
       (liste-tr (list-values num point))
       (liste-up (all-ups liste-tr))
       (liste-down (all-downs liste-tr))
       (liste-right (all-rights liste-tr))
       (liste-left (all-lefts liste-tr))
       (liste-front (all-fronts liste-tr))
       (liste-back (all-backs liste-tr))
       ;(value NIL)
        )
    (dotimes (jindex (length liste-tr))
      do (dotimes(jo (length sem-keys))
          do(let* ((pose (cl-transforms:origin (slot-value (gethash (nth jo sem-keys) sem-hash) 'sem-map-utils:pose)))
                   (npoint (cl-transforms:origin (nth jindex liste-tr)))
                   (upoint (cl-transforms:origin (nth jindex liste-up)))
                   (dpoint (cl-transforms:origin (nth jindex liste-down)))
                   (rpoint (cl-transforms:origin (nth jindex liste-right)))
                   (lpoint (cl-transforms:origin (nth jindex liste-left)))
                   (fpoint (cl-transforms:origin (nth jindex liste-front)))
                   (bpoint (cl-transforms:origin (nth jindex liste-back)))
                   (value (checker-at-distance pose npoint))
                   (uvalue (checker-at-distance pose upoint))
                   (dvalue (checker-at-distance pose dpoint))
                   (rvalue (checker-at-distance pose rpoint))
                   (lvalue (checker-at-distance pose lpoint))
                   (fvalue (checker-at-distance pose fpoint))
                   (bvalue (checker-at-distance pose  bpoint)))
                  (cond ((and (or (equal value T)
                                  (equal uvalue T)
                                  (equal dvalue T)
                                  (equal rvalue T)
                                  (equal lvalue T)
                                  (equal fvalue T)
                                  (equal bvalue T))
                             (not (equal (nth jo sem-keys)
                                         (find (nth jo sem-keys)
                                           elem :test #'equal))))
                        (location-costmap:publish-point  (cl-transforms:origin (nth jindex liste-tr)) :id (+ (+ jo jindex) 1000))
                        (location-costmap:publish-point  (cl-transforms:origin (nth jindex liste-right)) :id (+ (+ jo jindex) 2000))
                        (location-costmap:publish-point  (cl-transforms:origin (nth jindex liste-left)) :id (+ (+ jo jindex) 3000))
                         (location-costmap:publish-point  (cl-transforms:origin (nth jindex liste-front)) :id (+ (+ jo jindex) 4000))
                        (location-costmap:publish-point  (cl-transforms:origin (nth jindex liste-back )) :id (+ (+ jo jindex) 5000))
                        (location-costmap:publish-point  (cl-transforms:origin (nth jindex liste-up)) :id (+ (+ jo jindex) 6000))
                        (location-costmap:publish-point  (cl-transforms:origin (nth jindex liste-down)) :id (+ (+ jo jindex) 7000))
                        (setf elem (append (list (nth jo sem-keys)) elem)))
                        
                       (t
                    ;    (format t "~a~% und ~a~%" rpoint lpoint)
                         (location-costmap:publish-point  (cl-transforms:origin (nth jindex liste-tr)) :id (+ (+ jo jindex) 11000))
                        (location-costmap:publish-point  (cl-transforms:origin (nth jindex liste-right)) :id (+ (+ jo jindex) 22000))
                        (location-costmap:publish-point  (cl-transforms:origin (nth jindex liste-left)) :id (+ (+ jo jindex) 33000))
                         (location-costmap:publish-point  (cl-transforms:origin (nth jindex liste-front)) :id (+ (+ jo jindex) 44000))
                        (location-costmap:publish-point  (cl-transforms:origin (nth jindex liste-back )) :id (+ (+ jo jindex) 55000))
                        (location-costmap:publish-point  (cl-transforms:origin (nth jindex liste-up)) :id (+ (+ jo jindex) 66000))
                        (location-costmap:publish-point  (cl-transforms:origin (nth jindex liste-down)) :id (+ (+ jo jindex) 77000))                      
                          )))))
            ;(return)))
     
  ;            (swm->intern-tf-remover *puber*)
             (reverse elem)))

(defun hash-table-keys (hash-table)
                   "Return a list of keys in HASH-TABLE."
                   (let ((keys '()))
                     (maphash (lambda (k _v) (push k keys)) hash-table)
                     keys))

(defun give-calculated-obj-pointed-at (point sem-map)
  (let*((elem NIL)
        (num (make-list 100))
       ; (eps 0)(var 0)
        (sem-hash (slot-value sem-map 'sem-map-utils:parts))
        (sem-keys (hash-table-keys sem-hash))
        (liste-tr (list-values num point))
        (liste-up (all-points-ups liste-tr))
        (liste-down (all-points-downs liste-tr))
        (liste-right (all-points-rights liste-tr))
        (liste-left (all-points-lefts liste-tr))
        (liste-front (all-points-fronts liste-tr))
        (liste-back (all-points-backs liste-tr))
        ;(value NIL)
        )
    (format t "tetete~%")
    (dotimes (jindex (length liste-tr))
      do (dotimes(jo (length sem-keys))
           do(let* ((all (get-bbox-as-aabb (nth jo sem-keys) sem-hash))
                    (elem1 (first all))
                    (elem2 (second all))
                    (npoint (cl-transforms:origin (nth jindex liste-tr)))
                    (upoint (cl-transforms:origin (nth jindex liste-up)))
                    (dpoint (cl-transforms:origin (nth jindex liste-down)))
                    (rpoint (cl-transforms:origin (nth jindex liste-right)))
                    (lpoint (cl-transforms:origin (nth jindex liste-left)))
                    (fpoint (cl-transforms:origin (nth jindex liste-front)))
                    (bpoint (cl-transforms:origin (nth jindex liste-back)))
                    (value (semantic-map-costmap::inside-aabb elem1 elem2 npoint))
                    (uvalue (semantic-map-costmap::inside-aabb elem1 elem2 upoint))
                    (dvalue (semantic-map-costmap::inside-aabb elem1 elem2 dpoint))
                    (rvalue (semantic-map-costmap::inside-aabb elem1 elem2 rpoint))
                    (lvalue (semantic-map-costmap::inside-aabb elem1 elem2 lpoint))
                    (fvalue (semantic-map-costmap::inside-aabb elem1 elem2 fpoint))
                    (bvalue (semantic-map-costmap::inside-aabb elem1 elem2 bpoint)))
               (cond ((and (or (equal value T)
                               (equal uvalue T)
                               (equal dvalue T)
                               (equal rvalue T)
                               (equal lvalue T)
                               (equal fvalue T)
                               (equal bvalue T))
                           (not (equal (nth jo sem-keys)
                                       (find (nth jo sem-keys)
                                             elem :test #'equal))))
                      (location-costmap:publish-point  (cl-transforms:origin (nth jindex liste-tr)) :id (+ (+ jo jindex) 1000))
                      (location-costmap:publish-point  (cl-transforms:origin (nth jindex liste-right)) :id (+ (+ jo jindex) 2000))
                      (location-costmap:publish-point  (cl-transforms:origin (nth jindex liste-left)) :id (+ (+ jo jindex) 3000))
                      (location-costmap:publish-point  (cl-transforms:origin (nth jindex liste-front)) :id (+ (+ jo jindex) 4000))
                      (location-costmap:publish-point  (cl-transforms:origin (nth jindex liste-back )) :id (+ (+ jo jindex) 5000))
                      (location-costmap:publish-point  (cl-transforms:origin (nth jindex liste-up)) :id (+ (+ jo jindex) 6000))
                      (location-costmap:publish-point  (cl-transforms:origin (nth jindex liste-down)) :id (+ (+ jo jindex) 7000))
                      (setf elem (append (list (nth jo sem-keys)) elem)))
                     (t
                      (location-costmap:publish-point  (cl-transforms:origin (nth jindex liste-tr)) :id (+ (+ jo jindex) 11000))
                      (location-costmap:publish-point  (cl-transforms:origin (nth jindex liste-right)) :id (+ (+ jo jindex) 22000))
                      (location-costmap:publish-point  (cl-transforms:origin (nth jindex liste-left)) :id (+ (+ jo jindex) 33000))
                      (location-costmap:publish-point  (cl-transforms:origin (nth jindex liste-front)) :id (+ (+ jo jindex) 44000))
                      (location-costmap:publish-point  (cl-transforms:origin (nth jindex liste-back )) :id (+ (+ jo jindex) 55000))
                      (location-costmap:publish-point  (cl-transforms:origin (nth jindex liste-up)) :id (+ (+ jo jindex) 66000))
                      (location-costmap:publish-point  (cl-transforms:origin (nth jindex liste-down)) :id (+ (+ jo jindex) 77000)))))))
    ;;(return)))
    ;;(swm->intern-tf-remover *puber*)
             (reverse elem)))

(defun human-relative-map-pose ()
  (tf:lookup-transform *tf* "map" "human"))
;;test
(defun list-values (num point)
  (let*((zet 1.0)
        (iks (cl-transforms:x point))
        (yps (cl-transforms:y point))
        (liste-tr NIL)
        (humanpose (cl-transforms:transform->pose (human-relative-map-pose)))
        (temp '()))
    (cond((and (>= iks 0) 
               (<= yps 0))
          (setf liste-tr (function-up-right point iks yps zet num liste-tr humanpose)))
         ((and (<= iks 0)
               (<= yps 0))
          (setf liste-tr (function-down-right point iks yps zet num liste-tr humanpose)))
         ((and (<= iks 0) ;<=
               (>= yps 0)) ;>=
          (setf liste-tr (function-down-left point iks yps zet num liste-tr humanpose)))
         ((and (>= iks 0)
               (>= yps 0)) ;>=
          (setf liste-tr (function-up-left point iks yps zet num liste-tr humanpose)))
         (t()))
    (dotimes (index (length liste-tr))
     (setf temp (cons (cl-transforms:make-pose
                       (cl-transforms:origin (nth index liste-tr))
                       (cl-transforms:make-identity-rotation)) temp)))
    (reverse temp)))

(defun function-up-left (point iks yps zet num liste-tr humanpose)
  (cond((and (> iks 0)
              (<= iks 0.1) 
              (> yps 0))
          (dotimes(index (length num))
                do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector  (+ (cl-transforms:x point)  (* 0.1 index))  (+ (cl-transforms:y point) (* 0.5 index))  (+ (cl-transforms:z point) zet)) humanpose))))))
        ((and (> iks 0.1)
              (<= iks 0.3) 
              (> yps 0))
          (dotimes(index (length num))
            do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector  (+ (cl-transforms:x point)  (* 0.25 index))  (+ (cl-transforms:y point) (* 0.5 index))  (+ (cl-transforms:z point) zet)) humanpose))))))
        ((and (> iks 0.3)
              (<= iks 0.5) 
              (> yps 0))
         (dotimes(index (length num))
                do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector  (+ (cl-transforms:x point)  (* 0.4 index))  (+ (cl-transforms:y point) (* 0.5 index))  (+ (cl-transforms:z point) zet)) humanpose))))))
        ((and (> iks 0.5)
              (<= iks 0.7) 
              (> yps 0))
         (dotimes(index (length num))
                do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector  (+ (cl-transforms:x point)  (* 0.6 index))  (+ (cl-transforms:y point) (* 0.4 index))  (+ (cl-transforms:z point) zet)) humanpose))))))
        ((and (> iks 0.7)
              (<= iks 0.8) 
              (> yps 0))
         (dotimes(index (length num))
                do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector  (+ (cl-transforms:x point)  (* 0.7 index))  (+ (cl-transforms:y point) (* 0.3 index))  (+ (cl-transforms:z point) zet)) humanpose))))))
        ((and (> iks 0.8)
              (<= iks 0.9) 
              (> yps 0))
         (dotimes(index (length num))
                do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector  (+ (cl-transforms:x point)  (* 0.8 index))  (+ (cl-transforms:y point) (* 0.2 index))  (+ (cl-transforms:z point) zet)) humanpose))))))
        ((and (> iks 0.9)
              (<= iks 1) 
              (> yps 0))
         (dotimes(index (length num))
                do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector  (+ (cl-transforms:x point)  (* 0.9 index))  (+ (cl-transforms:y point) (* 0.1 index))  (+ (cl-transforms:z point) zet)) humanpose))))))
        (t()))
  liste-tr
  )

  (defun function-down-left (point iks yps zet num liste-tr humanpose)
    ;(format t "func-down-left~%")
    (cond((and (< iks 0) 
               (> yps 0)
               (<= yps 0.1))
          (dotimes(index (length num))
                do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector (+ (cl-transforms:x point) (* (- 0.85) index))  (+ (cl-transforms:y point)(* 0.1 index))  (+ (cl-transforms:z point) zet)) humanpose))))))
         ((and (< iks 0) 
               (> yps 0.1)
               (<= yps 0.3))
          (dotimes(index (length num))
                do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector (+ (cl-transforms:x point) (* (- 0.7) index))  (+ (cl-transforms:y point)(* 0.25 index))  (+ (cl-transforms:z point) zet)) humanpose))))))
         ((and (< iks 0) 
               (> yps 0.3)
               (<= yps 0.4))
          (dotimes(index (length num))
                do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector (+ (cl-transforms:x point) (* (- 0.6) index))  (+ (cl-transforms:y point)(* 0.4 index))  (+ (cl-transforms:z point) zet)) humanpose))))))
    ((and (< iks 0) 
               (> yps 0.4)
               (<= yps 0.5))
          (dotimes(index (length num))
                do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector (+ (cl-transforms:x point) (* (- 0.4) index))  (+ (cl-transforms:y point)(* 0.6 index))  (+ (cl-transforms:z point) zet)) humanpose))))))
    ((and (< iks 0) 
               (> yps 0.5)
               (<= yps 0.6))
     (dotimes(index (length num))
                do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector (+ (cl-transforms:x point) (* (- 0.3) index))  (+ (cl-transforms:y point)(* 0.7 index))  (+ (cl-transforms:z point) zet)) humanpose))))))
    ((and (< iks 0) 
          (> yps 0.6)
          (<= yps 0.7))
     (dotimes(index (length num))
                do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector (+ (cl-transforms:x point) (* (- 0.2) index))  (+ (cl-transforms:y point)(* 0.8 index))  (+ (cl-transforms:z point) zet)) humanpose))))))
    ((and (< iks 0) 
          (> yps 0.7)
          (<= yps 0.9))
     (dotimes(index (length num))
       do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector (+ (cl-transforms:x point) (* (- 0.1) index))  (+ (cl-transforms:y point)(* 0.9 index))  (+ (cl-transforms:z point) zet)) humanpose))))))
    ((and (= iks 0) 
          (> yps 0))
     (dotimes(index (length num))
                do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector (cl-transforms:x point)  (+ (cl-transforms:y point)(* 0.5 index))  (+ (cl-transforms:z point) zet))humanpose))))))
             (t ()))
             liste-tr)
 
(defun function-down-right (point iks yps zet num liste-tr humanpose)
 ; (format t "func down rohjt ~%")
  (cond((and (< iks 0) 
             (= yps 0))
        (dotimes(index (length num))
        do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector (+ (cl-transforms:x point) (* (- 0.5) index))  (cl-transforms:y point)  (+ (cl-transforms:z point) zet))humanpose))))))
       ((and (< iks 0) 
             (> yps -1)
             (<= yps -0.9))
        (dotimes(index (length num))
                do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector (+ (cl-transforms:x point) (* (- 0.1) index))  (+ (cl-transforms:y point)(* (- 0.9) index))  (+ (cl-transforms:z point) zet)) humanpose))))))
       ((and (< iks 0) 
             (> yps -1)
             (> yps -0.9)
             (<= yps -0.8))
        (dotimes(index (length num))
                do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector (+ (cl-transforms:x point) (* (- 0.2) index))  (+ (cl-transforms:y point)(* (- 0.8) index))  (+ (cl-transforms:z point) zet)) humanpose))))))
              ((and (< iks 0) 
             (> yps -1)
             (> yps -0.8)
             (<= yps -0.6))
               (dotimes(index (length num))
                do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector (+ (cl-transforms:x point) (* (- 0.3) index))  (+ (cl-transforms:y point)(* (- 0.7) index))  (+ (cl-transforms:z point) zet)) humanpose))))))
              ((and (< iks 0) 
             (> yps -1)
             (> yps -0.6)
             (<= yps -0.5))
          (dotimes(index (length num))
            do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector (+ (cl-transforms:x point) (* (- 0.4) index))  (+ (cl-transforms:y point)(* (- 0.6) index))  (+ (cl-transforms:z point) zet)) humanpose))))))
               ((and (< iks 0) 
             (> yps -1)
             (> yps -0.5)
             (<= yps -0.4))
                (dotimes(index (length num))
                do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector (+ (cl-transforms:x point) (* (- 0.5) index))  (+ (cl-transforms:y point)(* (- 0.5) index))  (+ (cl-transforms:z point) zet)) humanpose))))))
               ((and (< iks 0) 
                     (> yps -1)
                     (> yps -0.4)
                     (<= yps -0.3))
                (dotimes(index (length num))
                do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector (+ (cl-transforms:x point) (* (- 0.6) index))  (+ (cl-transforms:y point)(* (- 0.4) index))  (+ (cl-transforms:z point) zet)) humanpose))))))
                    ((and (< iks 0) 
                     (> yps -1)
                     (> yps -0.3)
                     (<= yps -0.2))
                     (dotimes(index (length num))
                do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector (+ (cl-transforms:x point) (* (- 0.7) index))  (+ (cl-transforms:y point)(* (- 0.3) index))  (+ (cl-transforms:z point) zet)) humanpose))))))
                         ((and (< iks 0) 
                     (> yps -1)
                     (> yps -0.2)
                     (<= yps -0.1))
                          (dotimes(index (length num))
                do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector (+ (cl-transforms:x point) (* (- 0.85) index))  (+ (cl-transforms:y point)(* (- 0.15) index))  (+ (cl-transforms:z point) zet)) humanpose))))))                    
             (t ()))
             liste-tr)  

(defun function-up-right (point iks yps zet num liste-tr humanpose)
  (cond((and (> iks 0)
             (= yps 0))
        (dotimes(index (length num))
                do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector (+ (cl-transforms:x point) (* 0.5 index))  (cl-transforms:y point)  (+ (cl-transforms:z point) zet)) humanpose))))))
         ((and (> iks 0) ;;ok
               (< yps 0)
               (>= yps (- 0.2)))
          (dotimes(index (length num))
                do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector (+ (cl-transforms:x point) (* 0.8 index))  (+ (cl-transforms:y point)(* (- 0.12) index))  (+ (cl-transforms:z point) zet)) humanpose))))))
         ((and (> iks 0) ;;ok
               (< yps 0)
               (< yps (- 0.2))
               (>= yps (- 0.4)))
          (dotimes(index (length num))
                do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector (+ (cl-transforms:x point) (* 0.8 index))  (+ (cl-transforms:y point)(* (- 0.25) index))  (+ (cl-transforms:z point) zet)) humanpose))))))
         ((and (> iks 0) ;;ok
               (< yps 0)
               (< yps (- 0.4))
               (>= yps (- 0.5)))
          (dotimes(index (length num))
            do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector (+ (cl-transforms:x point) (* 0.5 index))  (+ (cl-transforms:y point)(* (- 0.265) index))  (+ (cl-transforms:z point) zet)) humanpose))))))
  ((and (> iks 0) ;;ok
               (< yps 0)
               (< yps (- 0.5))
               (>= yps (- 0.6)))
           (dotimes(index (length num))
                do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector (+ (cl-transforms:x point) (* 0.5 index))  (+ (cl-transforms:y point)(* (- 0.35) index))  (+ (cl-transforms:z point) zet)) humanpose))))))
  ((and (> iks 0) ;;ok
                (< yps 0)
                (< yps (- 0.6))
                (>= yps (- 0.7)))
          (dotimes(index (length num))
           do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector (+ (cl-transforms:x point) (* 0.5 index))  (+ (cl-transforms:y point)(* (- 0.55) index))  (+ (cl-transforms:z point) zet)) humanpose))))))
          ((and (> iks 0) ;;ok
                (< yps 0)
                (< yps (- 0.7))
                (> yps (- 0.8)))
           (dotimes(index (length num))
             do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector (+ (cl-transforms:x point) (* 0.5 index))  (+ (cl-transforms:y point)(* (- 0.6) index))  (+ (cl-transforms:z point) zet)) humanpose))))))
          ((and (> iks 0) ;;ok
                (< yps 0)
               (<= yps (- 0.8))
               (> yps (- 0.9)))
           (dotimes(index (length num))
             do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector (+ (cl-transforms:x point) (* 0.35 index))  (+ (cl-transforms:y point)(* (- 0.7) index))  (+ (cl-transforms:z point) zet)) humanpose))))))
               ((and (> iks 0) ;;ok
                     (< yps 0)
               (<= yps (- 0.9))
               (>= yps (- 1)))
                (dotimes(index (length num))
                  do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector (+ (cl-transforms:x point) (* 0.2 index))  (+ (cl-transforms:y point)(*  (- 0.99) index))  (+ (cl-transforms:z point) zet)) humanpose))))))             
             ((and (= iks 0) ;;ok
                   (< yps 0))
             (dotimes(index (length num))
                do (setf liste-tr (append liste-tr (list (get-gesture->relative-world (cl-transforms:make-3d-vector (cl-transforms:x point)  (+ (cl-transforms:y point)(* (- 0.4) index))  (+ (cl-transforms:z point) zet)) humanpose))))))
             (t ()))
             liste-tr)

(defun all-points-ups (liste)
  (let*((test '()))
    (dotimes (index (length liste))
      (setf test (cons 
            (cl-transforms:make-pose
             (cl-transforms:make-3d-vector (cl-transforms:x (cl-transforms:origin (nth index liste)))
                                           (cl-transforms:y (cl-transforms:origin (nth index liste)))
                                           (+ (cl-transforms:z (cl-transforms:origin (nth index liste))) 1))
             (cl-transforms:orientation (nth index liste))) test)))
    (reverse test)))

(defun all-points-downs (liste)
   ; (format t "all-downs~%")
   (let*((test '()))
    (dotimes (index (length liste))
      (setf test (cons 
            (cl-transforms:make-pose
             (cl-transforms:make-3d-vector (cl-transforms:x (cl-transforms:origin (nth index liste)))
                                           (cl-transforms:y (cl-transforms:origin (nth index liste)))
                                           (- (cl-transforms:z (cl-transforms:origin (nth index liste))) 1))
             (cl-transforms:orientation (nth index liste))) test)))
    (reverse test)))

(defun all-points-rights (liste)
  (let*((test '()))
    (dotimes (index (length liste))
      (setf test (cons 
                  (cl-transforms:make-pose
                   (cl-transforms:make-3d-vector (cl-transforms:x (cl-transforms:origin (nth index liste)))
                                                 (+ (cl-transforms:y (cl-transforms:origin (nth index liste))) 1)
                                                 (cl-transforms:z (cl-transforms:origin (nth index liste))))
                   (cl-transforms:orientation (nth index liste))) test)))
    (reverse test)))

(defun all-points-lefts (liste)
 ; (format t "all-lefts~%")
    (let*((test '()))
    (dotimes (index (length liste))
      (setf test (cons 
            (cl-transforms:make-pose
             (cl-transforms:make-3d-vector (cl-transforms:x (cl-transforms:origin (nth index liste)))
                                           (- (cl-transforms:y (cl-transforms:origin (nth index liste))) 1)
                                           (cl-transforms:z (cl-transforms:origin (nth index liste))))
             (cl-transforms:orientation (nth index liste))) test)))
    (reverse test)))

(defun all-points-fronts (liste)
  ;(format t "all-fronts~%")
  (let*((test '()))
    (dotimes (index (length liste))
      (setf test (cons 
            (cl-transforms:make-pose
             (cl-transforms:make-3d-vector (+ (cl-transforms:x (cl-transforms:origin (nth index liste))) 1)
                                           (cl-transforms:y (cl-transforms:origin (nth index liste)))
                                           (cl-transforms:z (cl-transforms:origin (nth index liste))))
            (cl-transforms:orientation (nth index liste))) test)))
    (reverse test)))

(defun all-points-backs (liste)
  ;(format t "all-backs~%")
    (let*((test '()))
    (dotimes (index (length liste))
      (setf test (cons 
            (cl-transforms:make-pose
             (cl-transforms:make-3d-vector (- (cl-transforms:x (cl-transforms:origin (nth index liste))) 1)
                                           (cl-transforms:y (cl-transforms:origin (nth index liste)))
                                           (cl-transforms:z (cl-transforms:origin (nth index liste))))
             (cl-transforms:orientation (nth index liste))) test)))
    (reverse test)))


;;##########################CHECKING THE CALCULATED OBJECT#################################;;
(defun checking-pointed-object (elem gesture sem-map)
  (format t "checker-of-pointer~%")
  (let*((sym1 NIL)
        (sym2 NIL)
        (sym NIL))
    (cond ((not (equal NIL (elem-in-list elem sem-map)))
           (setf sym (elem-in-list elem sem-map)))
          (t (setf sym1 (give-calculated-obj-pointed-at gesture sem-map))
             (if (equal sym1 NIL)
                 (setf sym2 (objects-close-to-gesture gesture sem-map))
                 (format t ""))
             (cond ((> (length sym1) 0)
                    (dotimes(index (length sym1))
                      do(cond((and (string-equal elem  (get-elem-type (nth index sym1) sem-map))
                                   (equal sym NIL))
                              (setf sym (nth index sym1)))
                             (t ()))))
                   ((and (= (length sym1) 0)(> (length sym2) 0))
                    (dotimes(index (length sym2))
                      do(cond((and (string-equal elem  (get-elem-type (nth index sym2) sem-map))
                                   (equal sym NIL))
                              (setf sym (nth index sym2)))
                             (t ()))))
                   (t ()))))
    sym))


;;############################GROUND FOR POINTING GESTURE########################################;;
;; GROUND FOR GESTURE

(defun objects-close-to-gesture (vec sem-map)
 ; (setf puber (swm->intern-tf-creater))
  (let* ((elem NIL)
         (sem-hash (slot-value sem-map 'sem-map-utils:parts))
         (sem-keys (hash-table-keys sem-hash))
         (incrementer 0)
         (num (make-list 300))
         (valuable (list-values num vec)))
    (let*((liste (five-down-levels valuable)))
      (dotimes (mo (length liste))
        do (let*((new-point (nth mo liste))
                 (smarter (+ (* 10 incrementer) 2)))
             (dotimes (jndex (length sem-keys))
               do(let* ((elem1 (first (get-bbox-as-aabb (nth jndex sem-keys) sem-hash)))
                        (elem2 (second (get-bbox-as-aabb (nth jndex sem-keys) sem-hash))))
                   ;;  (smarter (+ smarter jndex)))
                   (setf value
                         (semantic-map-costmap::inside-aabb elem1 elem2  (cl-transforms:origin new-point)))
                   (cond ((equal value T)
                          ;;  (location-costmap::publish-point (cl-transforms:origin new-point) :id smarter)
                          (setf elem (append (list (nth jndex sem-keys)) elem))
                          (remove-duplicates elem))
                         (t ;;  (location-costmap::publish-point (cl-transforms:origin new-point) :id smarter)
                          )))
               (setf incrementer (+ incrementer 2))))))
    ;;  (swm->intern-tf-remover puber)
             (reverse (remove-duplicates elem)))) 


(defun get-gesture->relative-world (gesture-vec humanpose)
  (let*((ori (cl-transforms:make-3d-vector (+ (cl-transforms:x (cl-transforms:origin humanpose)) (cl-transforms:x gesture-vec))
                                          (+ (cl-transforms:y (cl-transforms:origin humanpose)) (cl-transforms:y gesture-vec))
                                          (+ (cl-transforms:z (cl-transforms:origin humanpose)) (cl-transforms:z gesture-vec))))
        (pose  (cl-transforms-stamped:make-pose ori (cl-transforms:orientation humanpose))))
    pose))

(defun checker-at-distance (ffpoint sspoint)
  (let*((spoint (cl-transforms:make-pose sspoint (cl-transforms:make-identity-rotation)))
        (fpoint (cl-transforms:make-pose ffpoint (cl-transforms:make-identity-rotation)))
        (fsec (sqrt (+ (square (- (cl-transforms:x (cl-transforms:origin spoint))
                                   (cl-transforms:x (cl-transforms:origin fpoint))))
                        (square (- (cl-transforms:y (cl-transforms:origin spoint))
                                   (cl-transforms:y (cl-transforms:origin fpoint))))
                        (square (- (cl-transforms:z (cl-transforms:origin spoint))
                                   (cl-transforms:z (cl-transforms:origin fpoint)))))))
        (forw2 (sqrt (+ (square (- (cl-transforms:x (cl-transforms:origin spoint))
                                   (+ (cl-transforms:x (cl-transforms:origin fpoint)) 1)))
                        (square (- (cl-transforms:y (cl-transforms:origin spoint))
                                   (cl-transforms:y (cl-transforms:origin fpoint))))
                        (square (- (cl-transforms:z (cl-transforms:origin spoint))
                                   (cl-transforms:z (cl-transforms:origin fpoint)))))))
        (backw2 (sqrt (+ (square (- (cl-transforms:x (cl-transforms:origin spoint))
                                   (- (cl-transforms:x (cl-transforms:origin fpoint)) 1)))
                        (square (- (cl-transforms:y (cl-transforms:origin spoint))
                                   (cl-transforms:y (cl-transforms:origin fpoint))))
                        (square (- (cl-transforms:z (cl-transforms:origin spoint))
                                   (cl-transforms:z (cl-transforms:origin fpoint)))))))
        (right2 (sqrt (+ (square (- (cl-transforms:x (cl-transforms:origin spoint))
                                    (cl-transforms:x (cl-transforms:origin fpoint))))
                         (square (- (cl-transforms:y (cl-transforms:origin spoint))
                                    (-  (cl-transforms:y (cl-transforms:origin fpoint)) 1)))
                        (square (- (cl-transforms:z (cl-transforms:origin spoint))
                                   (cl-transforms:z (cl-transforms:origin fpoint)))))))
        (left2 (sqrt (+ (square (- (cl-transforms:x (cl-transforms:origin spoint))
                                    (cl-transforms:x (cl-transforms:origin fpoint))))
                         (square (- (cl-transforms:y (cl-transforms:origin spoint))
                                    (+  (cl-transforms:y (cl-transforms:origin fpoint)) 1)))
                        (square (- (cl-transforms:z (cl-transforms:origin spoint))
                                   (cl-transforms:z (cl-transforms:origin fpoint)))))))
        (up2 (sqrt (+ (square (- (cl-transforms:x (cl-transforms:origin spoint))
                                    (cl-transforms:x (cl-transforms:origin fpoint))))
                         (square (- (cl-transforms:y (cl-transforms:origin spoint))
                                    (cl-transforms:y (cl-transforms:origin fpoint))))
                        (square (- (cl-transforms:z (cl-transforms:origin spoint))
                                   (+ (cl-transforms:z (cl-transforms:origin fpoint)) 2))))))
        (down2 (sqrt (+ (square (- (cl-transforms:x (cl-transforms:origin spoint))
                                 (cl-transforms:x (cl-transforms:origin fpoint))))
                      (square (- (cl-transforms:y (cl-transforms:origin spoint))
                                 (cl-transforms:y (cl-transforms:origin fpoint))))
                      (square (- (cl-transforms:z (cl-transforms:origin spoint))
                                 (+ (cl-transforms:z (cl-transforms:origin fpoint)) 2))))))
        (all (append (append (append (append (append (append (append '() (list fsec)) (list forw2)) (list backw2)) (list right2)) (list left2)) (list up2)) (list down2)))
        (value NIL))
    (dotimes(index (length all))
      (if (and (>= 2 (nth index all))
               (null value))
          (setf value T)))
  value))

(defun square (n)
  (* n n))

(defun all-ups (liste)
  (let*((test '()))
    (dotimes (index (length liste))
      (setf test (cons 
            (cl-transforms:make-pose
             (cl-transforms:make-3d-vector (cl-transforms:x (cl-transforms:origin (nth index liste)))
                                           (cl-transforms:y (cl-transforms:origin (nth index liste)))
                                           (+ (cl-transforms:z (cl-transforms:origin (nth index liste))) 1))
             (cl-transforms:orientation (nth index liste))) test)))
    (reverse test)))

(defun all-downs (liste)
   ; (format t "all-downs~%")
   (let*((test '()))
    (dotimes (index (length liste))
      (setf test (cons 
            (cl-transforms:make-pose
             (cl-transforms:make-3d-vector (cl-transforms:x (cl-transforms:origin (nth index liste)))
                                           (cl-transforms:y (cl-transforms:origin (nth index liste)))
                                           (- (cl-transforms:z (cl-transforms:origin (nth index liste))) 1))
             (cl-transforms:orientation (nth index liste))) test)))
    (reverse test)))

(defun all-rights (liste)
  (let*((test '()))
    (dotimes (index (length liste))
      (setf test (cons 
                  (cl-transforms:make-pose
                   (cl-transforms:make-3d-vector (cl-transforms:x (cl-transforms:origin (nth index liste)))
                                                 (+ (cl-transforms:y (cl-transforms:origin (nth index liste))) 1)
                                                 (cl-transforms:z (cl-transforms:origin (nth index liste))))
                   (cl-transforms:orientation (nth index liste))) test)))
    (reverse test)))

(defun all-lefts (liste)
 ; (format t "all-lefts~%")
    (let*((test '()))
    (dotimes (index (length liste))
      (setf test (cons 
            (cl-transforms:make-pose
             (cl-transforms:make-3d-vector (cl-transforms:x (cl-transforms:origin (nth index liste)))
                                           (- (cl-transforms:y (cl-transforms:origin (nth index liste))) 1)
                                           (cl-transforms:z (cl-transforms:origin (nth index liste))))
             (cl-transforms:orientation (nth index liste))) test)))
    (reverse test)))

(defun all-fronts (liste)
  ;(format t "all-fronts~%")
  (let*((test '()))
    (dotimes (index (length liste))
      (setf test (cons 
            (cl-transforms:make-pose
             (cl-transforms:make-3d-vector (+ (cl-transforms:x (cl-transforms:origin (nth index liste))) 1)
                                           (cl-transforms:y (cl-transforms:origin (nth index liste)))
                                           (cl-transforms:z (cl-transforms:origin (nth index liste))))
            (cl-transforms:orientation (nth index liste))) test)))
    (reverse test)))

(defun all-backs (liste)
  ;(format t "all-backs~%")
    (let*((test '()))
    (dotimes (index (length liste))
      (setf test (cons 
            (cl-transforms:make-pose
             (cl-transforms:make-3d-vector (- (cl-transforms:x (cl-transforms:origin (nth index liste))) 1)
                                           (cl-transforms:y (cl-transforms:origin (nth index liste)))
                                           (cl-transforms:z (cl-transforms:origin (nth index liste))))
             (cl-transforms:orientation (nth index liste))) test)))
    (reverse test)))
